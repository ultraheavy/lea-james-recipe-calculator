#!/usr/bin/env python3
"""
Fixed CSV Import Functions
Generated by CSV Import Diagnostics Tool
"""

import csv
import re
from typing import Dict, List, Tuple, Optional
from decimal import Decimal

class FixedCSVImporter:
    """Fixed CSV import functions that handle common issues"""
    
    @staticmethod
    def parse_measurement(measurement: str) -> Tuple[float, str]:
        """Parse measurement string into quantity and unit
        
        Handles patterns like:
        - "10 oz" -> (10.0, "oz")
        - "2 x 4 oz" -> (8.0, "oz")
        - "5" -> (5.0, "each")
        - "1 slice" -> (1.0, "slice")
        """
        if not measurement:
            return (0.0, "each")
            
        measurement = measurement.strip()
        
        # Handle "X x Y unit" pattern
        match = re.match(r'(\d+\.?\d*)\s*x\s*(\d+\.?\d*)\s*(\w+)', measurement)
        if match:
            qty1 = float(match.group(1))
            qty2 = float(match.group(2))
            unit = match.group(3)
            return (qty1 * qty2, unit)
            
        # Handle "X unit" pattern
        match = re.match(r'(\d+\.?\d*)\s*(.+)', measurement)
        if match:
            qty = float(match.group(1))
            unit = match.group(2).strip()
            return (qty, unit if unit else "each")
            
        # Handle just a number
        try:
            return (float(measurement), "each")
        except ValueError:
            # Handle just a unit (assume qty=1)
            return (1.0, measurement)
            
    @staticmethod
    def normalize_unit(unit: str) -> str:
        """Normalize unit abbreviations"""
        unit_map = {
            'fl': 'fl oz',
            'floz': 'fl oz',
            'oz': 'oz',
            'ounce': 'oz',
            'ounces': 'oz',
            'lb': 'lb',
            'lbs': 'lb',
            'pound': 'lb',
            'pounds': 'lb',
            'ea': 'each',
            'pc': 'each',
            'pcs': 'each',
            'piece': 'each',
            'pieces': 'each',
            'slice': 'slice',
            'slices': 'slice',
            'g': 'g',
            'gram': 'g',
            'grams': 'g',
            'kg': 'kg',
            'kilogram': 'kg',
            'kilograms': 'kg',
            'ml': 'ml',
            'milliliter': 'ml',
            'milliliters': 'ml',
            'l': 'L',
            'liter': 'L',
            'liters': 'L',
            'gal': 'gal',
            'gallon': 'gal',
            'gallons': 'gal',
            'qt': 'qt',
            'quart': 'qt',
            'quarts': 'qt',
            'pt': 'pt',
            'pint': 'pt',
            'pints': 'pt',
            'cup': 'cup',
            'cups': 'cup',
            'tbsp': 'tbsp',
            'tablespoon': 'tbsp',
            'tablespoons': 'tbsp',
            'tsp': 'tsp',
            'teaspoon': 'tsp',
            'teaspoons': 'tsp'
        }
        
        unit_lower = unit.lower().strip()
        return unit_map.get(unit_lower, unit)
        
    @staticmethod
    def parse_cost(cost_str: str) -> float:
        """Parse cost string, handling formulas and currency symbols
        
        Handles:
        - "$1.50" -> 1.50
        - "1.50" -> 1.50
        - "=B2*C2" -> 0.0 (with warning)
        - "$1,234.56" -> 1234.56
        """
        if not cost_str:
            return 0.0
            
        cost_str = str(cost_str).strip()
        
        # Check for formulas
        if cost_str.startswith('='):
            print(f"Warning: Formula found in cost field: {cost_str}")
            return 0.0
            
        # Remove currency symbols and commas
        cost_str = cost_str.replace('$', '').replace(',', '').strip()
        
        try:
            return float(cost_str)
        except ValueError:
            print(f"Warning: Could not parse cost: {cost_str}")
            return 0.0
            
    @staticmethod
    def detect_encoding(file_path: str) -> str:
        """Detect file encoding"""
        encodings = ['utf-8-sig', 'utf-8', 'latin-1', 'cp1252']
        
        for encoding in encodings:
            try:
                with open(file_path, 'r', encoding=encoding) as f:
                    f.read()
                return encoding
            except UnicodeDecodeError:
                continue
                
        # Default to utf-8
        return 'utf-8'
        
    @classmethod
    def parse_toast_recipe_csv(cls, file_path: str) -> Dict:
        """Parse Toast recipe CSV with all fixes applied"""
        encoding = cls.detect_encoding(file_path)
        
        with open(file_path, 'r', encoding=encoding) as f:
            lines = f.readlines()
            
        # Extract recipe name
        recipe_name = None
        for line in lines[:5]:
            if 'Recipe Name,' in line:
                parts = line.split(',')
                if len(parts) > 1:
                    recipe_name = parts[1].strip()
                break
                
        # Find ingredient section
        ingredients = []
        ingredient_start = -1
        
        for i, line in enumerate(lines):
            if 'Ingredient,Type,Measurement' in line:
                ingredient_start = i + 1
                break
                
        if ingredient_start > -1:
            for line in lines[ingredient_start:]:
                if not line.strip():
                    continue
                    
                parts = [p.strip('"').strip() for p in line.split(',')]
                if len(parts) >= 6 and parts[0]:
                    # Parse measurement
                    quantity, unit = cls.parse_measurement(parts[2])
                    unit = cls.normalize_unit(unit)
                    
                    # Parse cost
                    cost = cls.parse_cost(parts[5] if len(parts) > 5 else '0')
                    
                    ingredients.append({
                        'name': parts[0],
                        'type': parts[1] or 'Product',
                        'quantity': quantity,
                        'unit': unit,
                        'yield_percent': parts[3] if len(parts) > 3 else '100%',
                        'usable_yield': parts[4] if len(parts) > 4 else '100%',
                        'cost': cost
                    })
                    
        return {
            'recipe_name': recipe_name,
            'ingredients': ingredients
        }
        
    @classmethod
    def parse_toast_inventory_csv(cls, file_path: str) -> List[Dict]:
        """Parse Toast inventory CSV with all fixes applied"""
        encoding = cls.detect_encoding(file_path)
        items = []
        
        with open(file_path, 'r', encoding=encoding) as f:
            lines = f.readlines()
            
        # Find header line
        header_idx = -1
        for i, line in enumerate(lines):
            if 'Location Name,Vendor Name,Item Code' in line:
                header_idx = i
                break
                
        if header_idx == -1:
            return items
            
        reader = csv.DictReader(lines[header_idx:])
        for row in reader:
            # Build pack size
            pack = row.get('Pack', '').strip()
            size = row.get('Size', '').strip()
            uom = row.get('UOM', '').strip()
            
            # Normalize units
            uom = cls.normalize_unit(uom)
            
            # Build pack size string
            if pack and size and uom:
                if pack == '1':
                    pack_size = f"{size} {uom}"
                else:
                    pack_size = f"{pack} x {size} {uom}"
            elif size and uom:
                pack_size = f"{size} {uom}"
            else:
                pack_size = ''
                
            # Parse prices
            current_price = cls.parse_cost(row.get('Contracted Price ($)', '0'))
            last_price = cls.parse_cost(row.get('Last Purchased Price ($)', '0'))
            
            items.append({
                'item_code': row.get('Item Code', '').strip(),
                'description': row.get('Item Description', '').strip(),
                'vendor_name': row.get('Vendor Name', '').strip(),
                'pack_size': pack_size,
                'current_price': current_price,
                'last_purchased_price': last_price,
                'last_purchased_date': row.get('Last Purchased Date', '').strip(),
                'unit_measure': uom,
                'product_categories': row.get('Product(s)', '').strip()
            })
            
        return items

# Example usage:
if __name__ == '__main__':
    importer = FixedCSVImporter()
    
    # Parse a recipe CSV
    recipe_data = importer.parse_toast_recipe_csv('path/to/recipe.csv')
    print(f"Recipe: {recipe_data['recipe_name']}")
    for ing in recipe_data['ingredients']:
        print(f"  - {ing['name']}: {ing['quantity']} {ing['unit']} @ ${ing['cost']:.2f}")
